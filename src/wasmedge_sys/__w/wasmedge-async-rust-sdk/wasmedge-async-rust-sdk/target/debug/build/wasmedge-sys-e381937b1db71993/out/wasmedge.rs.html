<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/__w/wasmedge-async-rust-sdk/wasmedge-async-rust-sdk/./target/debug/build/wasmedge-sys-e381937b1db71993/out/wasmedge.rs`."><title>wasmedge.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../" data-static-root-path="../../../../../../../../../../static.files/" data-current-crate="wasmedge_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0-nightly (7adc89b69 2023-11-07)" data-channel="nightly" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../../../../../../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../../../../../../../../../../static.files/src-script-3280b574d94e47b4.js"></script><script defer src="../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/cncf/artwork/49169bdbc88a7ce3c4a722c641cc2d548bd5c340/projects/wasm-edge-runtime/icon/color/wasm-edge-runtime-icon-color.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../../../../../../../../../wasmedge_sys/index.html"><img src="https://github.com/cncf/artwork/blob/master/projects/wasm-edge-runtime/icon/color/wasm-edge-runtime-icon-color.png?raw=true" alt="wasmedge_sys"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
</pre></div><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.69.1 */

</span><span class="kw">pub const </span>__bool_true_false_are_defined : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>true_ : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>false_ : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>_STDINT_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_FEATURES_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_DEFAULT_SOURCE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__GLIBC_USE_ISOC2X : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__USE_ISOC11 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_ISOC99 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_ISOC95 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX_IMPLICITLY : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_POSIX_SOURCE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_POSIX_C_SOURCE : u32 = <span class="number">200809 </span>; <span class="kw">pub const </span>__USE_POSIX : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX2 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX199309 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_POSIX199506 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_XOPEN2K : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_XOPEN2K8 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_ATFILE_SOURCE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__WORDSIZE : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>__WORDSIZE_TIME64_COMPAT32 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__SYSCALL_WORDSIZE : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>__TIMESIZE : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>__USE_MISC : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_ATFILE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__USE_FORTIFY_LEVEL : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_DEPRECATED_GETS : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_DEPRECATED_SCANF : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>_STDC_PREDEF_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STDC_IEC_559__ : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STDC_IEC_60559_BFP__ : u32 = <span class="number">201404 </span>; <span class="kw">pub const </span>__STDC_IEC_559_COMPLEX__ : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STDC_IEC_60559_COMPLEX__ : u32 = <span class="number">201404 </span>; <span class="kw">pub const </span>__STDC_ISO_10646__ : u32 = <span class="number">201706 </span>; <span class="kw">pub const </span>__GNU_LIBRARY__ : u32 = <span class="number">6 </span>; <span class="kw">pub const </span>__GLIBC__ : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>__GLIBC_MINOR__ : u32 = <span class="number">35 </span>; <span class="kw">pub const </span>_SYS_CDEFS_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__glibc_c99_flexarr_available : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__HAVE_GENERIC_SELECTION : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__GLIBC_USE_LIB_EXT2 : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_BFP_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_BFP_EXT_C2X : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_FUNCS_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>__GLIBC_USE_IEC_60559_TYPES_EXT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>_BITS_TYPES_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_TYPESIZES_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__OFF_T_MATCHES_OFF64_T : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__INO_T_MATCHES_INO64_T : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__RLIM_T_MATCHES_RLIM64_T : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__STATFS_MATCHES_STATFS64 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>__FD_SETSIZE : u32 = <span class="number">1024 </span>; <span class="kw">pub const </span>_BITS_TIME64_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_WCHAR_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_STDINT_INTN_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>_BITS_STDINT_UINTN_H : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>INT8_MIN : i32 = - <span class="number">128 </span>; <span class="kw">pub const </span>INT16_MIN : i32 = - <span class="number">32768 </span>; <span class="kw">pub const </span>INT32_MIN : i32 = - <span class="number">2147483648 </span>; <span class="kw">pub const </span>INT8_MAX : u32 = <span class="number">127 </span>; <span class="kw">pub const </span>INT16_MAX : u32 = <span class="number">32767 </span>; <span class="kw">pub const </span>INT32_MAX : u32 = <span class="number">2147483647 </span>; <span class="kw">pub const </span>UINT8_MAX : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>UINT16_MAX : u32 = <span class="number">65535 </span>; <span class="kw">pub const </span>UINT32_MAX : u32 = <span class="number">4294967295 </span>; <span class="kw">pub const </span>INT_LEAST8_MIN : i32 = - <span class="number">128 </span>; <span class="kw">pub const </span>INT_LEAST16_MIN : i32 = - <span class="number">32768 </span>; <span class="kw">pub const </span>INT_LEAST32_MIN : i32 = - <span class="number">2147483648 </span>; <span class="kw">pub const </span>INT_LEAST8_MAX : u32 = <span class="number">127 </span>; <span class="kw">pub const </span>INT_LEAST16_MAX : u32 = <span class="number">32767 </span>; <span class="kw">pub const </span>INT_LEAST32_MAX : u32 = <span class="number">2147483647 </span>; <span class="kw">pub const </span>UINT_LEAST8_MAX : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>UINT_LEAST16_MAX : u32 = <span class="number">65535 </span>; <span class="kw">pub const </span>UINT_LEAST32_MAX : u32 = <span class="number">4294967295 </span>; <span class="kw">pub const </span>INT_FAST8_MIN : i32 = - <span class="number">128 </span>; <span class="kw">pub const </span>INT_FAST16_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>INT_FAST32_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>INT_FAST8_MAX : u32 = <span class="number">127 </span>; <span class="kw">pub const </span>INT_FAST16_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>INT_FAST32_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>UINT_FAST8_MAX : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>UINT_FAST16_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>UINT_FAST32_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>INTPTR_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>INTPTR_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>UINTPTR_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>PTRDIFF_MIN : i64 = - <span class="number">9223372036854775808 </span>; <span class="kw">pub const </span>PTRDIFF_MAX : u64 = <span class="number">9223372036854775807 </span>; <span class="kw">pub const </span>SIG_ATOMIC_MIN : i32 = - <span class="number">2147483648 </span>; <span class="kw">pub const </span>SIG_ATOMIC_MAX : u32 = <span class="number">2147483647 </span>; <span class="kw">pub const </span>SIZE_MAX : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>WINT_MIN : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>WINT_MAX : u32 = <span class="number">4294967295 </span>; <span class="kw">pub const </span>WASMEDGE_VERSION : &amp; [u8 ; <span class="number">7</span>] = <span class="string">b&quot;0.13.5\0&quot; </span>; <span class="kw">pub const </span>WASMEDGE_VERSION_MAJOR : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>WASMEDGE_VERSION_MINOR : u32 = <span class="number">13 </span>; <span class="kw">pub const </span>WASMEDGE_VERSION_PATCH : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>WasmEdge_Plugin_CurrentAPIVersion : u32 = <span class="number">2 </span>; <span class="kw">pub type </span>__u_char = :: std :: os :: raw :: c_uchar ; <span class="kw">pub type </span>__u_short = :: std :: os :: raw :: c_ushort ; <span class="kw">pub type </span>__u_int = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__u_long = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__int8_t = :: std :: os :: raw :: c_schar ; <span class="kw">pub type </span>__uint8_t = :: std :: os :: raw :: c_uchar ; <span class="kw">pub type </span>__int16_t = :: std :: os :: raw :: c_short ; <span class="kw">pub type </span>__uint16_t = :: std :: os :: raw :: c_ushort ; <span class="kw">pub type </span>__int32_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__uint32_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__int64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__uint64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__int_least8_t = __int8_t ; <span class="kw">pub type </span>__uint_least8_t = __uint8_t ; <span class="kw">pub type </span>__int_least16_t = __int16_t ; <span class="kw">pub type </span>__uint_least16_t = __uint16_t ; <span class="kw">pub type </span>__int_least32_t = __int32_t ; <span class="kw">pub type </span>__uint_least32_t = __uint32_t ; <span class="kw">pub type </span>__int_least64_t = __int64_t ; <span class="kw">pub type </span>__uint_least64_t = __uint64_t ; <span class="kw">pub type </span>__quad_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__u_quad_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__intmax_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__uintmax_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__dev_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__uid_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__gid_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__ino_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__ino64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__mode_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__nlink_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__off_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__off64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__pid_t = :: std :: os :: raw :: c_int ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__fsid_t { <span class="kw">pub </span>__val : [:: std :: os :: raw :: c_int ; <span class="number">2usize</span>] , } # [test] <span class="kw">fn </span>bindgen_test_layout___fsid_t () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; __fsid_t &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; __fsid_t &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (__fsid_t))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; __fsid_t &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (__fsid_t))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . __val) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (__fsid_t) , <span class="string">&quot;::&quot; </span>, stringify ! (__val))) ; } <span class="kw">pub type </span>__clock_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__rlim_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__rlim64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__id_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__time_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__useconds_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__suseconds_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__suseconds64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__daddr_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__key_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__clockid_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>__timer_t = * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; <span class="kw">pub type </span>__blksize_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__blkcnt_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__blkcnt64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__fsblkcnt_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsblkcnt64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsfilcnt_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsfilcnt64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__fsword_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__ssize_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__syscall_slong_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__syscall_ulong_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>__loff_t = __off64_t ; <span class="kw">pub type </span>__caddr_t = * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char ; <span class="kw">pub type </span>__intptr_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>__socklen_t = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>__sig_atomic_t = :: std :: os :: raw :: c_int ; <span class="kw">pub type </span>int_least8_t = __int_least8_t ; <span class="kw">pub type </span>int_least16_t = __int_least16_t ; <span class="kw">pub type </span>int_least32_t = __int_least32_t ; <span class="kw">pub type </span>int_least64_t = __int_least64_t ; <span class="kw">pub type </span>uint_least8_t = __uint_least8_t ; <span class="kw">pub type </span>uint_least16_t = __uint_least16_t ; <span class="kw">pub type </span>uint_least32_t = __uint_least32_t ; <span class="kw">pub type </span>uint_least64_t = __uint_least64_t ; <span class="kw">pub type </span>int_fast8_t = :: std :: os :: raw :: c_schar ; <span class="kw">pub type </span>int_fast16_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>int_fast32_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>int_fast64_t = :: std :: os :: raw :: c_long ; <span class="kw">pub type </span>uint_fast8_t = :: std :: os :: raw :: c_uchar ; <span class="kw">pub type </span>uint_fast16_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>uint_fast32_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>uint_fast64_t = :: std :: os :: raw :: c_ulong ; <span class="kw">pub type </span>intmax_t = __intmax_t ; <span class="kw">pub type </span>uintmax_t = __uintmax_t ; <span class="kw">pub const </span>WasmEdge_Proposal_ImportExportMutGlobals : WasmEdge_Proposal = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_NonTrapFloatToIntConversions : WasmEdge_Proposal = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_SignExtensionOperators : WasmEdge_Proposal = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_MultiValue : WasmEdge_Proposal = <span class="number">3 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_BulkMemoryOperations : WasmEdge_Proposal = <span class="number">4 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_ReferenceTypes : WasmEdge_Proposal = <span class="number">5 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_SIMD : WasmEdge_Proposal = <span class="number">6 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_TailCall : WasmEdge_Proposal = <span class="number">7 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_MultiMemories : WasmEdge_Proposal = <span class="number">8 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_Annotations : WasmEdge_Proposal = <span class="number">9 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_Memory64 : WasmEdge_Proposal = <span class="number">10 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_ExceptionHandling : WasmEdge_Proposal = <span class="number">11 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_ExtendedConst : WasmEdge_Proposal = <span class="number">12 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_Threads : WasmEdge_Proposal = <span class="number">13 </span>; <span class="kw">pub const </span>WasmEdge_Proposal_FunctionReferences : WasmEdge_Proposal = <span class="number">14 </span>; <span class="kw">pub type </span>WasmEdge_Proposal = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_HostRegistration_Wasi : WasmEdge_HostRegistration = <span class="number">0 </span>; <span class="kw">pub type </span>WasmEdge_HostRegistration = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O0 : WasmEdge_CompilerOptimizationLevel = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O1 : WasmEdge_CompilerOptimizationLevel = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O2 : WasmEdge_CompilerOptimizationLevel = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_O3 : WasmEdge_CompilerOptimizationLevel = <span class="number">3 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_Os : WasmEdge_CompilerOptimizationLevel = <span class="number">4 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOptimizationLevel_Oz : WasmEdge_CompilerOptimizationLevel = <span class="number">5 </span>; <span class="kw">pub type </span>WasmEdge_CompilerOptimizationLevel = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_CompilerOutputFormat_Native : WasmEdge_CompilerOutputFormat = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_CompilerOutputFormat_Wasm : WasmEdge_CompilerOutputFormat = <span class="number">1 </span>; <span class="kw">pub type </span>WasmEdge_CompilerOutputFormat = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ErrCategory_WASM : WasmEdge_ErrCategory = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_ErrCategory_UserLevelError : WasmEdge_ErrCategory = <span class="number">1 </span>; <span class="kw">pub type </span>WasmEdge_ErrCategory = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ErrCode_Success : WasmEdge_ErrCode = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_Terminated : WasmEdge_ErrCode = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_RuntimeError : WasmEdge_ErrCode = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_CostLimitExceeded : WasmEdge_ErrCode = <span class="number">3 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_WrongVMWorkflow : WasmEdge_ErrCode = <span class="number">4 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_FuncNotFound : WasmEdge_ErrCode = <span class="number">5 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_AOTDisabled : WasmEdge_ErrCode = <span class="number">6 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_Interrupted : WasmEdge_ErrCode = <span class="number">7 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_NotValidated : WasmEdge_ErrCode = <span class="number">8 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UserDefError : WasmEdge_ErrCode = <span class="number">9 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IllegalPath : WasmEdge_ErrCode = <span class="number">32 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ReadError : WasmEdge_ErrCode = <span class="number">33 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UnexpectedEnd : WasmEdge_ErrCode = <span class="number">34 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedMagic : WasmEdge_ErrCode = <span class="number">35 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedVersion : WasmEdge_ErrCode = <span class="number">36 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedSection : WasmEdge_ErrCode = <span class="number">37 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_SectionSizeMismatch : WasmEdge_ErrCode = <span class="number">38 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_LengthOutOfBounds : WasmEdge_ErrCode = <span class="number">39 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_JunkSection : WasmEdge_ErrCode = <span class="number">40 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IncompatibleFuncCode : WasmEdge_ErrCode = <span class="number">41 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IncompatibleDataCount : WasmEdge_ErrCode = <span class="number">42 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DataCountRequired : WasmEdge_ErrCode = <span class="number">43 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedImportKind : WasmEdge_ErrCode = <span class="number">44 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedExportKind : WasmEdge_ErrCode = <span class="number">45 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ExpectedZeroByte : WasmEdge_ErrCode = <span class="number">46 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidMut : WasmEdge_ErrCode = <span class="number">47 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_TooManyLocals : WasmEdge_ErrCode = <span class="number">48 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedValType : WasmEdge_ErrCode = <span class="number">49 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedElemType : WasmEdge_ErrCode = <span class="number">50 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedRefType : WasmEdge_ErrCode = <span class="number">51 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MalformedUTF8 : WasmEdge_ErrCode = <span class="number">52 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntegerTooLarge : WasmEdge_ErrCode = <span class="number">53 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntegerTooLong : WasmEdge_ErrCode = <span class="number">54 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IllegalOpCode : WasmEdge_ErrCode = <span class="number">55 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ENDCodeExpected : WasmEdge_ErrCode = <span class="number">56 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IllegalGrammar : WasmEdge_ErrCode = <span class="number">57 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_SharedMemoryNoMax : WasmEdge_ErrCode = <span class="number">58 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntrinsicsTableNotFound : WasmEdge_ErrCode = <span class="number">59 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidAlignment : WasmEdge_ErrCode = <span class="number">64 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_TypeCheckFailed : WasmEdge_ErrCode = <span class="number">65 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLabelIdx : WasmEdge_ErrCode = <span class="number">66 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLocalIdx : WasmEdge_ErrCode = <span class="number">67 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidFuncTypeIdx : WasmEdge_ErrCode = <span class="number">68 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidFuncIdx : WasmEdge_ErrCode = <span class="number">69 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidTableIdx : WasmEdge_ErrCode = <span class="number">70 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidMemoryIdx : WasmEdge_ErrCode = <span class="number">71 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidGlobalIdx : WasmEdge_ErrCode = <span class="number">72 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidElemIdx : WasmEdge_ErrCode = <span class="number">73 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidDataIdx : WasmEdge_ErrCode = <span class="number">74 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidRefIdx : WasmEdge_ErrCode = <span class="number">75 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ConstExprRequired : WasmEdge_ErrCode = <span class="number">76 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DupExportName : WasmEdge_ErrCode = <span class="number">77 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ImmutableGlobal : WasmEdge_ErrCode = <span class="number">78 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidResultArity : WasmEdge_ErrCode = <span class="number">79 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MultiTables : WasmEdge_ErrCode = <span class="number">80 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MultiMemories : WasmEdge_ErrCode = <span class="number">81 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLimit : WasmEdge_ErrCode = <span class="number">82 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidMemPages : WasmEdge_ErrCode = <span class="number">83 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidStartFunc : WasmEdge_ErrCode = <span class="number">84 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidLaneIdx : WasmEdge_ErrCode = <span class="number">85 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ModuleNameConflict : WasmEdge_ErrCode = <span class="number">96 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IncompatibleImportType : WasmEdge_ErrCode = <span class="number">97 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UnknownImport : WasmEdge_ErrCode = <span class="number">98 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DataSegDoesNotFit : WasmEdge_ErrCode = <span class="number">99 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ElemSegDoesNotFit : WasmEdge_ErrCode = <span class="number">100 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_WrongInstanceAddress : WasmEdge_ErrCode = <span class="number">128 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_WrongInstanceIndex : WasmEdge_ErrCode = <span class="number">129 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InstrTypeMismatch : WasmEdge_ErrCode = <span class="number">130 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_FuncSigMismatch : WasmEdge_ErrCode = <span class="number">131 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_DivideByZero : WasmEdge_ErrCode = <span class="number">132 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IntegerOverflow : WasmEdge_ErrCode = <span class="number">133 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_InvalidConvToInt : WasmEdge_ErrCode = <span class="number">134 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_TableOutOfBounds : WasmEdge_ErrCode = <span class="number">135 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_MemoryOutOfBounds : WasmEdge_ErrCode = <span class="number">136 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_Unreachable : WasmEdge_ErrCode = <span class="number">137 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UninitializedElement : WasmEdge_ErrCode = <span class="number">138 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UndefinedElement : WasmEdge_ErrCode = <span class="number">139 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_IndirectCallTypeMismatch : WasmEdge_ErrCode = <span class="number">140 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_HostFuncError : WasmEdge_ErrCode = <span class="number">141 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_RefTypeMismatch : WasmEdge_ErrCode = <span class="number">142 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_UnalignedAtomicAccess : WasmEdge_ErrCode = <span class="number">143 </span>; <span class="kw">pub const </span>WasmEdge_ErrCode_ExpectSharedMemory : WasmEdge_ErrCode = <span class="number">144 </span>; <span class="kw">pub type </span>WasmEdge_ErrCode = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ValType_I32 : WasmEdge_ValType = <span class="number">127 </span>; <span class="kw">pub const </span>WasmEdge_ValType_I64 : WasmEdge_ValType = <span class="number">126 </span>; <span class="kw">pub const </span>WasmEdge_ValType_F32 : WasmEdge_ValType = <span class="number">125 </span>; <span class="kw">pub const </span>WasmEdge_ValType_F64 : WasmEdge_ValType = <span class="number">124 </span>; <span class="kw">pub const </span>WasmEdge_ValType_V128 : WasmEdge_ValType = <span class="number">123 </span>; <span class="kw">pub const </span>WasmEdge_ValType_FuncRef : WasmEdge_ValType = <span class="number">112 </span>; <span class="kw">pub const </span>WasmEdge_ValType_ExternRef : WasmEdge_ValType = <span class="number">111 </span>; <span class="kw">pub type </span>WasmEdge_ValType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_NumType_I32 : WasmEdge_NumType = <span class="number">127 </span>; <span class="kw">pub const </span>WasmEdge_NumType_I64 : WasmEdge_NumType = <span class="number">126 </span>; <span class="kw">pub const </span>WasmEdge_NumType_F32 : WasmEdge_NumType = <span class="number">125 </span>; <span class="kw">pub const </span>WasmEdge_NumType_F64 : WasmEdge_NumType = <span class="number">124 </span>; <span class="kw">pub const </span>WasmEdge_NumType_V128 : WasmEdge_NumType = <span class="number">123 </span>; <span class="kw">pub type </span>WasmEdge_NumType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_RefType_FuncRef : WasmEdge_RefType = <span class="number">112 </span>; <span class="kw">pub const </span>WasmEdge_RefType_ExternRef : WasmEdge_RefType = <span class="number">111 </span>; <span class="kw">pub type </span>WasmEdge_RefType = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_Mutability_Const : WasmEdge_Mutability = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_Mutability_Var : WasmEdge_Mutability = <span class="number">1 </span>; <span class="kw">pub type </span>WasmEdge_Mutability = :: std :: os :: raw :: c_uint ; <span class="kw">pub const </span>WasmEdge_ExternalType_Function : WasmEdge_ExternalType = <span class="number">0 </span>; <span class="kw">pub const </span>WasmEdge_ExternalType_Table : WasmEdge_ExternalType = <span class="number">1 </span>; <span class="kw">pub const </span>WasmEdge_ExternalType_Memory : WasmEdge_ExternalType = <span class="number">2 </span>; <span class="kw">pub const </span>WasmEdge_ExternalType_Global : WasmEdge_ExternalType = <span class="number">3 </span>; <span class="kw">pub type </span>WasmEdge_ExternalType = :: std :: os :: raw :: c_uint ; <span class="kw">pub type </span>uint128_t = u128 ; <span class="kw">pub type </span>int128_t = i128 ; # [doc = <span class="string">&quot; WasmEdge WASM value struct.&quot;</span>] # [repr (C)] # [repr (align (<span class="number">16</span>))] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Value { <span class="kw">pub </span>Value : uint128_t , <span class="kw">pub </span>Type : WasmEdge_ValType , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_Value () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_Value &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_Value &gt; () , <span class="number">32usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_Value))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_Value &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_Value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Value) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Value) , <span class="string">&quot;::&quot; </span>, stringify ! (Value))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Type) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Value) , <span class="string">&quot;::&quot; </span>, stringify ! (Type))) ; } # [doc = <span class="string">&quot; WasmEdge string struct.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_String { <span class="kw">pub </span>Length : u32 , <span class="kw">pub </span>Buf : * <span class="kw">const </span>:: std :: os :: raw :: c_char , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_String () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_String &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_String &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_String))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_String &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_String))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Length) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_String) , <span class="string">&quot;::&quot; </span>, stringify ! (Length))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Buf) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_String) , <span class="string">&quot;::&quot; </span>, stringify ! (Buf))) ; } # [doc = <span class="string">&quot; WasmEdge result struct.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Result { <span class="kw">pub </span>Code : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_Result () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_Result &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_Result &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_Result))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_Result &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_Result))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Code) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Result) , <span class="string">&quot;::&quot; </span>, stringify ! (Code))) ; } # [doc = <span class="string">&quot; Struct of WASM limit.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Limit { # [doc = <span class="string">&quot; Boolean to describe has max value or not.&quot;</span>] <span class="kw">pub </span>HasMax : bool , # [doc = <span class="string">&quot; Boolean to describe is shared memory or not.&quot;</span>] <span class="kw">pub </span>Shared : bool , # [doc = <span class="string">&quot; Minimum value.&quot;</span>] <span class="kw">pub </span>Min : u32 , # [doc = <span class="string">&quot; Maximum value. Will be ignored if the `HasMax` is false.&quot;</span>] <span class="kw">pub </span>Max : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_Limit () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_Limit &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_Limit &gt; () , <span class="number">12usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_Limit))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_Limit &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_Limit))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . HasMax) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (HasMax))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Shared) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">1usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (Shared))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Min) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (Min))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Max) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_Limit) , <span class="string">&quot;::&quot; </span>, stringify ! (Max))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ConfigureContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_StatisticsContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ASTModuleContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_FunctionTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_MemoryTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_TableTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_GlobalTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ImportTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ExportTypeContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_CompilerContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_LoaderContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ValidatorContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ExecutorContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_StoreContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ModuleInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_FunctionInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_TableInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_MemoryInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_GlobalInstanceContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_CallingFrameContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_Async { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_VMContext { _unused : [u8 ; <span class="number">0</span>] , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_PluginContext { _unused : [u8 ; <span class="number">0</span>] , } # [doc = <span class="string">&quot; No option value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_None : WasmEdge_ProgramOptionType = <span class="number">0 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Toggle : WasmEdge_ProgramOptionType = <span class="number">1 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int8 : WasmEdge_ProgramOptionType = <span class="number">2 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int16 : WasmEdge_ProgramOptionType = <span class="number">3 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int32 : WasmEdge_ProgramOptionType = <span class="number">4 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Int64 : WasmEdge_ProgramOptionType = <span class="number">5 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt8 : WasmEdge_ProgramOptionType = <span class="number">6 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt16 : WasmEdge_ProgramOptionType = <span class="number">7 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt32 : WasmEdge_ProgramOptionType = <span class="number">8 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_UInt64 : WasmEdge_ProgramOptionType = <span class="number">9 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Float : WasmEdge_ProgramOptionType = <span class="number">10 </span>; # [doc = <span class="string">&quot; Boolean value.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_Double : WasmEdge_ProgramOptionType = <span class="number">11 </span>; # [doc = <span class="string">&quot; WasmEdge_String.&quot;</span>] <span class="kw">pub const </span>WasmEdge_ProgramOptionType_String : WasmEdge_ProgramOptionType = <span class="number">12 </span>; # [doc = <span class="string">&quot; Type of option value.&quot;</span>] <span class="kw">pub type </span>WasmEdge_ProgramOptionType = :: std :: os :: raw :: c_uint ; # [doc = <span class="string">&quot; Program option for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ProgramOption { <span class="kw">pub </span>Name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Description : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Type : WasmEdge_ProgramOptionType , <span class="kw">pub </span>Storage : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>DefaultValue : * <span class="kw">const </span>:: std :: os :: raw :: c_void , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_ProgramOption () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_ProgramOption &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_ProgramOption &gt; () , <span class="number">40usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_ProgramOption))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_ProgramOption &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_ProgramOption))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Description) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Description))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Type) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Type))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Storage) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">24usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (Storage))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . DefaultValue) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">32usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ProgramOption) , <span class="string">&quot;::&quot; </span>, stringify ! (DefaultValue))) ; } # [doc = <span class="string">&quot; Module descriptor for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_ModuleDescriptor { <span class="kw">pub </span>Name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Description : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Create : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(arg1 : * <span class="kw">const </span>WasmEdge_ModuleDescriptor) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext &gt; , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_ModuleDescriptor () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_ModuleDescriptor &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_ModuleDescriptor &gt; () , <span class="number">24usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_ModuleDescriptor &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Description) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Description))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Create) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_ModuleDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Create))) ; } # [doc = <span class="string">&quot; Version data for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_PluginVersionData { <span class="kw">pub </span>Major : u32 , <span class="kw">pub </span>Minor : u32 , <span class="kw">pub </span>Patch : u32 , <span class="kw">pub </span>Build : u32 , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_PluginVersionData () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_PluginVersionData &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_PluginVersionData &gt; () , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_PluginVersionData))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_PluginVersionData &gt; () , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_PluginVersionData))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Major) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Major))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Minor) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">4usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Minor))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Patch) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Patch))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Build) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">12usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginVersionData) , <span class="string">&quot;::&quot; </span>, stringify ! (Build))) ; } # [doc = <span class="string">&quot; Plugin descriptor for plugins.&quot;</span>] # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>WasmEdge_PluginDescriptor { <span class="kw">pub </span>Name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>Description : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>APIVersion : u32 , <span class="kw">pub </span>Version : WasmEdge_PluginVersionData , <span class="kw">pub </span>ModuleCount : u32 , <span class="kw">pub </span>ProgramOptionCount : u32 , <span class="kw">pub </span>ModuleDescriptions : * <span class="kw-2">mut </span>WasmEdge_ModuleDescriptor , <span class="kw">pub </span>ProgramOptions : * <span class="kw-2">mut </span>WasmEdge_ProgramOption , } # [test] <span class="kw">fn </span>bindgen_test_layout_WasmEdge_PluginDescriptor () { <span class="kw">const </span>UNINIT : :: std :: mem :: MaybeUninit &lt; WasmEdge_PluginDescriptor &gt; = :: std :: mem :: MaybeUninit :: uninit () ; <span class="kw">let </span>ptr = UNINIT . as_ptr () ; assert_eq ! (:: std :: mem :: size_of :: &lt; WasmEdge_PluginDescriptor &gt; () , <span class="number">64usize </span>, concat ! (<span class="string">&quot;Size of: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor))) ; assert_eq ! (:: std :: mem :: align_of :: &lt; WasmEdge_PluginDescriptor &gt; () , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Alignment of &quot; </span>, stringify ! (WasmEdge_PluginDescriptor))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Name) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">0usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Name))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Description) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">8usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Description))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . APIVersion) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">16usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (APIVersion))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . Version) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">20usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (Version))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ModuleCount) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">36usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ModuleCount))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ProgramOptionCount) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">40usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ProgramOptionCount))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ModuleDescriptions) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">48usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ModuleDescriptions))) ; assert_eq ! (<span class="kw">unsafe </span>{ :: std :: ptr :: addr_of ! ((* ptr) . ProgramOptions) <span class="kw">as </span>usize - ptr <span class="kw">as </span>usize } , <span class="number">56usize </span>, concat ! (<span class="string">&quot;Offset of field: &quot; </span>, stringify ! (WasmEdge_PluginDescriptor) , <span class="string">&quot;::&quot; </span>, stringify ! (ProgramOptions))) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the version string of the WasmEdge C API.\n\n The returned string must __NOT__ be destroyed.\n\n \\returns NULL-terminated C string of version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGet () -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the major version value of the WasmEdge C API.\n\n \\returns Value of the major version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGetMajor () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the minor version value of the WasmEdge C API.\n\n \\returns Value of the minor version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGetMinor () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the patch version value of the WasmEdge C API.\n\n \\returns Value of the patch version.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VersionGetPatch () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the logging system to filter to error level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LogSetErrorLevel () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the logging system to filter to debug level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LogSetDebugLevel () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the logging system off.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LogOff () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the I32 WASM value.\n\n \\param Val the I32 value.\n\n \\returns WasmEdge_Value struct with the I32 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenI32 (Val : i32) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the I64 WASM value.\n\n \\param Val the I64 value.\n\n \\returns WasmEdge_Value struct with the I64 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenI64 (Val : i64) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the F32 WASM value.\n\n \\param Val the F32 value.\n\n \\returns WasmEdge_Value struct with the F32 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenF32 (Val : f32) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the F64 WASM value.\n\n \\param Val the F64 value.\n\n \\returns WasmEdge_Value struct with the F64 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenF64 (Val : f64) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the V128 WASM value.\n\n \\param Val the V128 value.\n\n \\returns WasmEdge_Value struct with the V128 value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenV128 (Val : int128_t) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the NULL reference WASM value.\n\n The values generated by this function are only meaningful when the\n `WasmEdge_Proposal_BulkMemoryOperations` or the\n `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.\n\n \\param T the reference type.\n\n \\returns WasmEdge_Value struct with the NULL reference.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenNullRef (T : WasmEdge_RefType) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the function reference WASM value.\n\n The values generated by this function are only meaningful when the\n `WasmEdge_Proposal_BulkMemoryOperations` or the\n `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.\n\n \\param Cxt the function instance context to convert to the reference.\n\n \\returns WasmEdge_Value struct with the function reference.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenFuncRef (Cxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the function reference WASM value.\n\n The values generated by this function are only meaningful when the\n `WasmEdge_Proposal_ReferenceTypes` turns on in configuration.\n\n \\param Ref the reference to the external object.\n\n \\returns WasmEdge_Value struct with the external reference.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGenExternRef (Ref : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the I32 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns I32 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetI32 (Val : WasmEdge_Value) -&gt; i32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the I64 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns I64 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetI64 (Val : WasmEdge_Value) -&gt; i64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the F32 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns F32 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetF32 (Val : WasmEdge_Value) -&gt; f32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the F64 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns F64 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetF64 (Val : WasmEdge_Value) -&gt; f64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the V128 value from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns V128 value in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetV128 (Val : WasmEdge_Value) -&gt; int128_t ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Specify the WASM value is a null reference or not.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns true if the value is a null reference, false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueIsNullRef (Val : WasmEdge_Value) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the function instance context from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns pointer to function instance context in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetFuncRef (Val : WasmEdge_Value) -&gt; * <span class="kw">const </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Retrieve the external reference from the WASM value.\n\n \\param Val the WasmEdge_Value struct.\n\n \\returns external reference in the input struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValueGetExternRef (Val : WasmEdge_Value) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_String with the C string.\n\n The caller owns the object and should call `WasmEdge_StringDelete` to\n destroy it. This function only supports the C string with NULL termination.\n If the input string may have `\\0` character, please use the\n `WasmEdge_StringCreateByBuffer` instead.\n\n \\param Str the NULL-terminated C string to copy into the WasmEdge_String\n object.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed or\n the input string is a NULL.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringCreateByCString (Str : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_String with the buffer and its length.\n\n The caller owns the object and should call `WasmEdge_StringDelete` to\n destroy it.\n\n \\param Buf the buffer to copy into the WasmEdge_String object.\n \\param Len the buffer length.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed or\n the input buffer is a NULL.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringCreateByBuffer (Buf : * <span class="kw">const </span>:: std :: os :: raw :: c_char , Len : u32) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Create the WasmEdge_String wraps to the buffer.\n\n This function creates a `WasmEdge_String` object which wraps to the input\n buffer. The caller should guarantee the life cycle of the input buffer, and\n should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Buf the buffer to copy into the WasmEdge_String object.\n \\param Len the buffer length.\n\n \\returns string object refer to the input buffer with its length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringWrap (Buf : * <span class="kw">const </span>:: std :: os :: raw :: c_char , Len : u32) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compare the two WasmEdge_String objects.\n\n \\param Str1 the first WasmEdge_String object to compare.\n \\param Str2 the second WasmEdge_String object to compare.\n\n \\returns true if the content of two WasmEdge_String objects are the same,\n false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringIsEqual (Str1 : WasmEdge_String , Str2 : WasmEdge_String) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Copy the content of WasmEdge_String object to the buffer.\n\n This function copy at most `Len` characters from the `WasmEdge_String`\n object to the destination buffer. If the string length is less than `Len`\n characters long, the remainder of the buffer is filled with `\\0&#39; characters.\n Otherwise, the destination is not terminated.\n\n \\param Str the source WasmEdge_String object to copy.\n \\param Buf the buffer to fill the string content.\n \\param Len the buffer length.\n\n \\returns the copied length of string.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringCopy (Str : WasmEdge_String , Buf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_String.\n\n After calling this function, the resources in the WasmEdge_String object\n will be released and the object should __NOT__ be used.\n\n \\param Str the WasmEdge_String object to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StringDelete (Str : WasmEdge_String) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Check the result is a success or not.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns true if the error code is WasmEdge_Result_Success or\n WasmEdge_Result_Terminate, false for others.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultOK (Res : WasmEdge_Result) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Generate the result with code.\n\n \\param Category the WasmEdge_ErrCategory to specify the error category.\n \\param Code the 24-bit length error code. The data exceeds 24 bits will be\n stripped.\n\n \\returns WasmEdge_Result struct with the given data.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGen (Category : WasmEdge_ErrCategory , Code : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the result code.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns result code (24-bit size data) in the WasmEdge_Result struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGetCode (Res : WasmEdge_Result) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the error category.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns error category in the WasmEdge_Result struct.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGetCategory (Res : WasmEdge_Result) -&gt; WasmEdge_ErrCategory ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the result message.\n\n The returned string must __NOT__ be destroyed.\n If the error category of the result is __NOT__ `WasmEdge_ErrCategory_WASM`,\n the message will always be \&quot;user defined error code\&quot;.\n\n \\param Res the WasmEdge_Result struct.\n\n \\returns NULL-terminated C string of the corresponding error message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ResultGetMessage (Res : WasmEdge_Result) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compare the two WasmEdge_Limit objects.\n\n \\param Lim1 the first WasmEdge_Limit object to compare.\n \\param Lim2 the second WasmEdge_Limit object to compare.\n\n \\returns true if the content of two WasmEdge_Limit objects are the same,\n false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LimitIsEqual (Lim1 : WasmEdge_Limit , Lim2 : WasmEdge_Limit) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ConfigureContext.\n\n The caller owns the object and should call `WasmEdge_ConfigureDelete` to\n destroy it.\n\n \\returns pointer to the context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCreate () -&gt; * <span class="kw-2">mut </span>WasmEdge_ConfigureContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a proposal setting into the WasmEdge_ConfigureContext.\n\n For turning on a specific WASM proposal in VM, loader, or compiler contexts,\n etc., you can set the proposal value into the WasmEdge_ConfigureContext and\n create the VM, loader, or compiler contexts, etc. with this context.\n\n ```c\n WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_BulkMemoryOperations);\n WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_ReferenceTypes);\n WasmEdge_ConfigureAddProposal(Conf, WasmEdge_Proposal_SIMD);\n WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);\n ```\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to add the proposal value.\n \\param Prop the proposal value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureAddProposal (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Prop : WasmEdge_Proposal) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Remove a proposal setting in the WasmEdge_ConfigureContext.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to remove the proposal.\n \\param Prop the proposal value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureRemoveProposal (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Prop : WasmEdge_Proposal) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Check if a proposal setting exists in the WasmEdge_ConfigureContext or not.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to check the proposal value.\n \\param Prop the proposal value.\n\n \\returns true if the proposal setting exists, false if not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureHasProposal (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , Prop : WasmEdge_Proposal) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a built-in host registration setting into WasmEdge_ConfigureContext.\n\n For turning on the Wasi support in `WasmEdge_VMContext`, you can set the\n built-in host registration value into the `WasmEdge_ConfigureContext` and\n create VM with this context.\n\n ```c\n WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\n WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);\n ```\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to add built-in host registration.\n \\param Host the built-in host registration value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureAddHostRegistration (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Host : WasmEdge_HostRegistration) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Remove a built-in host registration setting in the\n WasmEdge_ConfigureContext.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to remove the host\n pre-registration.\n \\param Host the built-in host registration value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureRemoveHostRegistration (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Host : WasmEdge_HostRegistration) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Check if a built-in host registration setting exists in the\n WasmEdge_ConfigureContext or not.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to check the host pre-registration.\n \\param Host the built-in host registration value.\n\n \\returns true if the built-in host registration setting exists, false if\n not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureHasHostRegistration (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , Host : WasmEdge_HostRegistration) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the page limit of memory instances.\n\n Limit the page count (64KiB per page) in memory instances.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the maximum page count.\n \\param Page the maximum page count.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureSetMaxMemoryPage (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Page : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the setting of the page limit of memory instances.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the maximum page count\n setting.\n\n \\returns the page count limitation value.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureGetMaxMemoryPage (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the force interpreter mode execution option.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsForceInterpreter the boolean value to determine to forcibly run\n WASM in interpreter mode or not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureSetForceInterpreter (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsForceInterpreter : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the force interpreter mode execution option.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to forcibly run WASM in interpreter\n mode or not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureIsForceInterpreter (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the option of enabling/disabling AF_UNIX support in the WASI socket.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param EnableAFUNIX the boolean value to determine to enable\n the AF_UNIX support in the WASI socket or not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureSetAllowAFUNIX (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , EnableAFUNIX : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the AllowAFUNIX option.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to enable AF_UNIX support in the\n WASI socket or not.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureIsAllowAFUNIX (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the optimization level of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the optimization level.\n \\param Level the AOT compiler optimization level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetOptimizationLevel (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Level : WasmEdge_CompilerOptimizationLevel) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the optimization level of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the optimization level.\n\n \\returns the AOT compiler optimization level.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerGetOptimizationLevel (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; WasmEdge_CompilerOptimizationLevel ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the output binary format of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the output binary format.\n \\param Format the AOT compiler output binary format.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetOutputFormat (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , Format : WasmEdge_CompilerOutputFormat) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the output binary format of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the output binary format.\n\n \\returns the AOT compiler output binary format.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerGetOutputFormat (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; WasmEdge_CompilerOutputFormat ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the dump IR option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsDump the boolean value to determine to dump IR or not when\n compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetDumpIR (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsDump : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the dump IR option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to dump IR or not when compilation\n in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerIsDumpIR (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the generic binary option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsGeneric the boolean value to determine to generate the generic\n binary or not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetGenericBinary (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsGeneric : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the generic binary option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to generate the generic binary or\n not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerIsGenericBinary (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the interruptible option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsInterruptible the boolean value to determine to generate\n interruptible binary or not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerSetInterruptible (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsInterruptible : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the interruptible option of the AOT compiler.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to generate interruptible binary or\n not when compilation in AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureCompilerIsInterruptible (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the instruction counting option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsCount the boolean value to determine to support instruction\n counting when execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsSetInstructionCounting (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsCount : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the instruction counting option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to support instruction counting when\n execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsIsInstructionCounting (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the cost measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsMeasure the boolean value to determine to support cost measuring\n when execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsSetCostMeasuring (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsMeasure : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the cost measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to support cost measuring when\n execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsIsCostMeasuring (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the time measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to set the boolean value.\n \\param IsMeasure the boolean value to determine to support time when\n execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsSetTimeMeasuring (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext , IsMeasure : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the time measuring option for the statistics.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to get the boolean value.\n\n \\returns the boolean value to determine to support time measuring when\n execution or not after compilation by the AOT compiler.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureStatisticsIsTimeMeasuring (Cxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ConfigureContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ConfigureContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ConfigureDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ConfigureContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_StatisticsContext.\n\n The caller owns the object and should call `WasmEdge_StatisticsDelete` to\n destroy it.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsCreate () -&gt; * <span class="kw-2">mut </span>WasmEdge_StatisticsContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the instruction count in execution.\n\n \\param Cxt the WasmEdge_StatisticsContext to get data.\n\n \\returns the instruction count in total execution.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsGetInstrCount (Cxt : * <span class="kw">const </span>WasmEdge_StatisticsContext) -&gt; u64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the instruction count per second in execution.\n\n \\param Cxt the WasmEdge_StatisticsContext to get data.\n\n \\returns the instruction count per second.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsGetInstrPerSecond (Cxt : * <span class="kw">const </span>WasmEdge_StatisticsContext) -&gt; f64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the total cost in execution.\n\n \\param Cxt the WasmEdge_StatisticsContext to get data.\n\n \\returns the total cost.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsGetTotalCost (Cxt : * <span class="kw">const </span>WasmEdge_StatisticsContext) -&gt; u64 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the costs of instructions.\n\n \\param Cxt the WasmEdge_StatisticsContext to set the cost table.\n \\param CostArr the cost table array.\n \\param Len the length of the cost table array.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsSetCostTable (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext , CostArr : * <span class="kw-2">mut </span>u64 , Len : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the cost limit in execution.\n\n The WASM execution will be aborted if the instruction costs exceeded the\n limit and the ErrCode::Value::CostLimitExceeded will be returned.\n\n \\param Cxt the WasmEdge_StatisticsContext to set the cost table.\n \\param Limit the cost limit.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsSetCostLimit (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext , Limit : u64) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Clear all data in the WasmEdge_StatisticsContext.\n\n \\param Cxt the WasmEdge_StatisticsContext to clear.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsClear (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_StatisticsContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_StatisticsContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StatisticsDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of imports list of the AST module.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n\n \\returns length of the imports list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListImportsLength (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the imports of the AST module.\n\n If the `Imports` buffer length is smaller than the result of the imports\n list size, the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n \\param [out] Imports the import type contexts buffer. Can be NULL if import\n types are not needed.\n \\param Len the buffer length.\n\n \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListImports (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Imports : * <span class="kw-2">mut </span>* <span class="kw">const </span>WasmEdge_ImportTypeContext , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exports list of the AST module.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n\n \\returns length of the exports list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListExportsLength (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exports of the AST module.\n\n If the `Exports` buffer length is smaller than the result of the exports\n list size, the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_ASTModuleContext.\n \\param [out] Exports the export type contexts buffer. Can be NULL if export\n types are not needed.\n \\param Len the buffer length.\n\n \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleListExports (Cxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Exports : * <span class="kw-2">mut </span>* <span class="kw">const </span>WasmEdge_ExportTypeContext , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ASTModuleContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ASTModuleContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ASTModuleDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ASTModuleContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_FunctionTypeContext.\n\n The caller owns the object and should call `WasmEdge_FunctionTypeDelete` to\n destroy it.\n\n \\param ParamList the value types list of parameters. NULL if the length is\n 0.\n \\param ParamLen the ParamList buffer length.\n \\param ReturnList the value types list of returns. NULL if the length is 0.\n \\param ReturnLen the ReturnList buffer length.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeCreate (ParamList : * <span class="kw">const </span>WasmEdge_ValType , ParamLen : u32 , ReturnList : * <span class="kw">const </span>WasmEdge_ValType , ReturnLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the parameter types list length from the WasmEdge_FunctionTypeContext.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n\n \\returns the parameter types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetParametersLength (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the parameter types list from the WasmEdge_FunctionTypeContext.\n\n If the `List` buffer length is smaller than the length of the parameter type\n list, the overflowed values will be discarded.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n \\param [out] List the WasmEdge_ValType buffer to fill the parameter value\n types.\n \\param Len the value type buffer length.\n\n \\returns the actual parameter types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetParameters (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , List : * <span class="kw-2">mut </span>WasmEdge_ValType , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the return types list length from the WasmEdge_FunctionTypeContext.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n\n \\returns the return types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetReturnsLength (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the return types list from the WasmEdge_FunctionTypeContext.\n\n If the `List` buffer length is smaller than the length of the return type\n list, the overflowed values will be discarded.\n\n \\param Cxt the WasmEdge_FunctionTypeContext.\n \\param [out] List the WasmEdge_ValType buffer to fill the return value\n types.\n \\param Len the value type buffer length.\n\n \\returns the actual return types list length.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeGetReturns (Cxt : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , List : * <span class="kw-2">mut </span>WasmEdge_ValType , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_FunctionTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_FunctionTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_FunctionTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_TableTypeContext.\n\n The caller owns the object and should call `WasmEdge_TableTypeDelete` to\n destroy it.\n\n \\param RefType the reference type of the table type.\n \\param Limit the limit struct of the table type.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeCreate (RefType : WasmEdge_RefType , Limit : WasmEdge_Limit) -&gt; * <span class="kw-2">mut </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the reference type from a table type.\n\n \\param Cxt the WasmEdge_TableTypeContext.\n\n \\returns the reference type of the table type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeGetRefType (Cxt : * <span class="kw">const </span>WasmEdge_TableTypeContext) -&gt; WasmEdge_RefType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the limit from a table type.\n\n \\param Cxt the WasmEdge_TableTypeContext.\n\n \\returns the limit struct of the table type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeGetLimit (Cxt : * <span class="kw">const </span>WasmEdge_TableTypeContext) -&gt; WasmEdge_Limit ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_TableTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_TableTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_MemoryTypeContext.\n\n The caller owns the object and should call `WasmEdge_MemoryTypeDelete` to\n destroy it.\n\n \\param Limit the limit struct of the memory type.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryTypeCreate (Limit : WasmEdge_Limit) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the limit from a memory type.\n\n \\param Cxt the WasmEdge_MemoryTypeContext.\n\n \\returns the limit struct of the memory type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryTypeGetLimit (Cxt : * <span class="kw">const </span>WasmEdge_MemoryTypeContext) -&gt; WasmEdge_Limit ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_MemoryTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_MemoryTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_GlobalTypeContext.\n\n The caller owns the object and should call `WasmEdge_GlobalTypeDelete` to\n destroy it.\n\n \\param ValType the value type of the global type.\n \\param Mut the mutation of the global type.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeCreate (ValType : WasmEdge_ValType , Mut : WasmEdge_Mutability) -&gt; * <span class="kw-2">mut </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the value type from a global type.\n\n \\param Cxt the WasmEdge_GlobalTypeContext.\n\n \\returns the value type of the global type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeGetValType (Cxt : * <span class="kw">const </span>WasmEdge_GlobalTypeContext) -&gt; WasmEdge_ValType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the mutability from a global type.\n\n \\param Cxt the WasmEdge_GlobalTypeContext.\n\n \\returns the mutability of the global type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeGetMutability (Cxt : * <span class="kw">const </span>WasmEdge_GlobalTypeContext) -&gt; WasmEdge_Mutability ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_GlobalTypeContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_GlobalTypeContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalTypeDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_GlobalTypeContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external type from an import type.\n\n \\param Cxt the WasmEdge_ImportTypeContext.\n\n \\returns the external type of the import type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetExternalType (Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; WasmEdge_ExternalType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module name from an import type.\n\n The returned string object is linked to the module name of the import type,\n and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ImportTypeContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetModuleName (Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external name from an import type.\n\n The returned string object is linked to the external name of the import\n type, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ImportTypeContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetExternalName (Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is function type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The function type context links to the function type in the import type\n context and the AST module context. The caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the function type. NULL if failed or the external type of the\n import type is not `WasmEdge_ExternalType_Function`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetFunctionType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is table type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The table type context links to the table type in the import type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_TableTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the table type. NULL if failed or the external type of the import\n type is not `WasmEdge_ExternalType_Table`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetTableType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is memory type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The memory type context links to the memory type in the import type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_MemoryTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the memory type. NULL if failed or the external type of the import\n type is not `WasmEdge_ExternalType_Memory`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetMemoryType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is global type) from an import type.\n\n The import type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The global type context links to the global type in the import type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_GlobalTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ImportTypeContext which queried from the `ASTCxt`.\n\n \\returns the global type. NULL if failed or the external type of the import\n type is not `WasmEdge_ExternalType_Global`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ImportTypeGetGlobalType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ImportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external type from an export type.\n\n \\param Cxt the WasmEdge_ExportTypeContext.\n\n \\returns the external type of the export type.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetExternalType (Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; WasmEdge_ExternalType ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external name from an export type.\n\n The returned string object is linked to the external name of the export\n type, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ExportTypeContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetExternalName (Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is function type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The function type context links to the function type in the export type\n context and the AST module context. The caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the function type. NULL if failed or the external type of the\n export type is not `WasmEdge_ExternalType_Function`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetFunctionType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is table type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The table type context links to the table type in the export type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_TableTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the table type. NULL if failed or the external type of the export\n type is not `WasmEdge_ExternalType_Table`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetTableType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is memory type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The memory type context links to the memory type in the export type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_MemoryTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the memory type. NULL if failed or the external type of the export\n type is not `WasmEdge_ExternalType_Memory`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetMemoryType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the external value (which is global type) from an export type.\n\n The export type context should be the one queried from the AST module\n context, or this function will cause unexpected error.\n The global type context links to the global type in the export type context\n and the AST module context. The caller should __NOT__ call the\n `WasmEdge_GlobalTypeDelete`.\n\n \\param ASTCxt the WasmEdge_ASTModuleContext.\n \\param Cxt the WasmEdge_ExportTypeContext which queried from the `ASTCxt`.\n\n \\returns the global type. NULL if failed or the external type of the export\n type is not `WasmEdge_ExternalType_Global`.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExportTypeGetGlobalType (ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , Cxt : * <span class="kw">const </span>WasmEdge_ExportTypeContext) -&gt; * <span class="kw">const </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_CompilerContext.\n\n The caller owns the object and should call `WasmEdge_CompilerDelete` to\n delete it.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_CompilerContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compile the input WASM from the file path.\n\n The compiler compiles the WASM from file path for the ahead-of-time mode and\n store the result to the output file path.\n\n \\param Cxt the WasmEdge_CompilerContext.\n \\param InPath the input WASM file path.\n \\param OutPath the output WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerCompile (Cxt : * <span class="kw-2">mut </span>WasmEdge_CompilerContext , InPath : * <span class="kw">const </span>:: std :: os :: raw :: c_char , OutPath : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Compile the input WASM from the given buffer.\n\n The compiler compiles the WASM from the given buffer for the\n ahead-of-time mode and store the result to the output file path.\n\n \\param Cxt the WasmEdge_CompilerContext.\n \\param InBuffer the input WASM binary buffer.\n \\param InBufferLen the length of the input WASM binary buffer.\n \\param OutPath the output WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerCompileFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_CompilerContext , InBuffer : * <span class="kw">const </span>u8 , InBufferLen : u64 , OutPath : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_CompilerContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_CompilerContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CompilerDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_CompilerContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_LoaderContext.\n\n The caller owns the object and should call `WasmEdge_LoaderDelete` to\n destroy it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of Loader.\n NULL for the default configuration.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_LoaderContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load and parse the WASM module from a WASM file into a\n WasmEdge_ASTModuleContext.\n\n Load and parse the WASM module from the file path, and return a\n `WasmEdge_ASTModuleContext` as the result. The caller owns the\n `WasmEdge_ASTModuleContext` object and should call\n `WasmEdge_ASTModuleDelete` to destroy it.\n\n \\param Cxt the WasmEdge_LoaderContext.\n \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded.\n \\param Path the NULL-terminated C string of the WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderParseFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_LoaderContext , Module : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ASTModuleContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load and parse the WASM module from a buffer into WasmEdge_ASTModuleContext.\n\n Load and parse the WASM module from a buffer, and return a\n WasmEdge_ASTModuleContext as the result. The caller owns the\n WasmEdge_ASTModuleContext object and should call `WasmEdge_ASTModuleDelete`\n to destroy it.\n\n \\param Cxt the WasmEdge_LoaderContext.\n \\param [out] Module the output WasmEdge_ASTModuleContext if succeeded.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderParseFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_LoaderContext , Module : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ASTModuleContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_LoaderContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_LoaderContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_LoaderDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_LoaderContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ValidatorContext.\n\n The caller owns the object and should call `WasmEdge_ValidatorDelete` to\n destroy it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of\n Validator. NULL for the default configuration.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValidatorCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ValidatorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Validate the WasmEdge AST Module.\n\n \\param Cxt the WasmEdge_ValidatorContext.\n \\param ASTCxt the WasmEdge_ASTModuleContext to validate.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValidatorValidate (Cxt : * <span class="kw-2">mut </span>WasmEdge_ValidatorContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ValidatorContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ValidatorContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ValidatorDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ValidatorContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ExecutorContext.\n\n The caller owns the object and should call `WasmEdge_ExecutorDelete` to\n delete it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of\n Executor. NULL for the default configuration.\n \\param StatCxt the WasmEdge_StatisticsContext as the statistics object set\n into Executor. The statistics will refer to this context, and the life cycle\n should be guaranteed until the executor context is deleted. NULL for not\n doing the statistics.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , StatCxt : * <span class="kw-2">mut </span>WasmEdge_StatisticsContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ExecutorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate an AST Module into a module instance.\n\n Instantiate an AST Module, and return an instantiated module instance\n context as the result. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it. Developers can use the\n `WasmEdge_ModuleInstanceListFunction`,\n `WasmEdge_ModuleInstanceFindFunction`, etc. APIs to retrieve the exported\n instances from the result module instance.\n\n \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.\n \\param [out] ModuleCxt the output WasmEdge_ModuleInstanceContext if\n succeeded.\n \\param StoreCxt the WasmEdge_StoreContext to link the imports.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorInstantiate (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , ModuleCxt : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate an AST Module into a named module instance and link into store.\n\n Instantiate an AST Module with the module name, return the instantiated\n module instance context as the result, and also register the module instance\n to the store. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it.\n Developers can use the `WasmEdge_ModuleInstanceListFunction`,\n `WasmEdge_ModuleInstanceFindFunction`, etc. APIs to retrieve the exported\n instances from the result module instance.\n After calling this function, the output module instance will also be\n registered into the store, and the other modules can import the exported\n instances for linking when instantiation. Developers SHOULD guarantee the\n life cycle of this output module instance, or the error will occur when in\n execution after the module instance being destroyed if it has been imported\n by other modules. That is, developers have the responsibility to delete the\n output module instance even though the store being destroyed. When the\n module instance is deleted, it will be unregistered to the store\n automatically.\n\n \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.\n \\param [out] ModuleCxt the output WasmEdge_ModuleInstanceContext if\n succeeded.\n \\param StoreCxt the WasmEdge_StoreContext to link the imports.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n \\param ModuleName the module name WasmEdge_String for all exported\n instances.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorRegister (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , ModuleCxt : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , ModuleName : WasmEdge_String) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register a module instance into a store with exporting its module name.\n\n Register an existing module into the store with its module name.\n After calling this function, the existing module instance will be registered\n into the store, and the other modules can import the exported instances for\n linking when instantiation. Developers SHOULD guarantee the life cycle of\n this existing module instance, or the error will occur when in execution\n after the module instance being destroyed if it has been imported by other\n modules. When the module instance is deleted, it will be unregistered to the\n store automatically.\n\n \\param Cxt the WasmEdge_ExecutorContext to instantiate the module.\n \\param StoreCxt the WasmEdge_StoreContext to store the instantiated module.\n \\param ImportCxt the WasmEdge_ModuleInstanceContext to register.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorRegisterImport (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext , ImportCxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Invoke a WASM function by the function instance.\n\n After instantiating a WASM module, developers can get the function instance\n context from the module instance. Then developers can invoke the function\n through this API.\n\n \\param Cxt the WasmEdge_ExecutorContext.\n \\param FuncCxt the function instance context to invoke.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorInvoke (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , FuncCxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Asynchronous invoke a WASM function by the function instance.\n\n After instantiating a WASM module, developers can get the function instance\n context from the module instance. Then developers can invoke the function\n asynchronously through this API.\n\n \\param Cxt the WasmEdge_ExecutorContext.\n \\param FuncCxt the function instance context to invoke.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorAsyncInvoke (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , FuncCxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ExecutorContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ExecutorContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_StoreContext.\n\n The caller owns the object and should call `WasmEdge_StoreDelete` to destroy\n it.\n The store is the linker for multiple WASM module instances. The store will\n not own any module instance registered into it, and the module instances\n will automatically be unregistered if they are destroyed.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreCreate () -&gt; * <span class="kw-2">mut </span>WasmEdge_StoreContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module instance context by the module name.\n\n After registering a WASM module, developers can call this function to find\n and get the registered module instance context by the module name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_StoreContext.\n \\param Name the module name WasmEdge_String.\n\n \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreFindModule (Cxt : * <span class="kw">const </span>WasmEdge_StoreContext , Name : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of registered module list in store.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_StoreContext.\n\n \\returns length of registered named module list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreListModuleLength (Cxt : * <span class="kw">const </span>WasmEdge_StoreContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the registered module names.\n\n This function will list all registered module names.\n The returned module names filled into the `Names` array are linked to the\n registered module names in the store context, and the caller should __NOT__\n call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the registered\n named module list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_StoreContext.\n \\param [out] Names the output names WasmEdge_String buffer of named modules.\n \\param Len the buffer length.\n\n \\returns actual registered named module list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreListModule (Cxt : * <span class="kw">const </span>WasmEdge_StoreContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_StoreContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n If there are module instances registered into this store context, they will\n be automatically un-link to this store context.\n\n \\param Cxt the WasmEdge_StoreContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_StoreDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ModuleInstanceContext.\n\n Create a module instance context with exported module name for host\n instances. Developer can use this API to create a module instance for\n collecting host functions, tables, memories, and globals.\n The caller owns the object and should call `WasmEdge_ModuleInstanceDelete`\n to destroy it.\n\n \\param ModuleName the module name WasmEdge_String of this host module to\n import.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceCreate (ModuleName : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ModuleInstanceContext with host data.\n\n Create a module instance context with exported module name, host data, and\n host data finalizer for host instances. Developer can use this API to create\n a module instance for collecting host functions, tables, memories, and\n globals. When this created module instance being destroyed, the host data\n finalizer will be invoked. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it.\n\n \\param ModuleName the module name WasmEdge_String of this host module to\n import.\n \\param HostData the host data to set into the module instance. When calling\n the finalizer, this pointer will become the argument of the finalizer\n function.\n \\param Finalizer the function to finalize the host data.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceCreateWithData (ModuleName : WasmEdge_String , HostData : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Finalizer : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) &gt;) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_ModuleInstanceContext for the WASI specification.\n\n This function will create a WASI host module that contains the WASI host\n functions and initialize it. The caller owns the object and should call\n `WasmEdge_ModuleInstanceDelete` to destroy it.\n\n \\param Args the command line arguments. The first argument suggests being\n the program name. NULL if the length is 0.\n \\param ArgLen the length of the command line arguments.\n \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the\n length is 0.\n \\param EnvLen the length of the environment variables.\n \\param Preopens the directory paths to preopen. String format in\n `GUEST_PATH:HOST_PATH` means the path mapping, or the same path will be\n mapped. NULL if the length is 0.\n \\param PreopenLen the length of the directory paths to preopen.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceCreateWASI (Args : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , ArgLen : u32 , Envs : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , EnvLen : u32 , Preopens : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , PreopenLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Initialize the WasmEdge_ModuleInstanceContext for the WASI specification.\n\n This function will initialize the WASI host module with the parameters.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.\n \\param Args the command line arguments. The first argument suggests being\n the program name. NULL if the length is 0.\n \\param ArgLen the length of the command line arguments.\n \\param Envs the environment variables in the format `ENV=VALUE`. NULL if the\n length is 0.\n \\param EnvLen the length of the environment variables.\n \\param Preopens the directory paths to preopen. String format in\n `GUEST_PATH:HOST_PATH` means the path mapping, or the same path will be\n mapped. NULL if the length is 0.\n \\param PreopenLen the length of the directory paths to preopen.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceInitWASI (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Args : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , ArgLen : u32 , Envs : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , EnvLen : u32 , Preopens : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , PreopenLen : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the WASI exit code.\n\n This function will return the exit code after running the \&quot;_start\&quot; function\n of a `wasm32-wasi` program.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.\n\n \\returns the exit code after executing the \&quot;_start\&quot; function. Return\n `EXIT_FAILURE` if the `Cxt` is NULL or not a WASI host module.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceWASIGetExitCode (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the native handler from the WASI mapped FD/Handler.\n\n This function will return the raw FD/Handler from a given mapped Fd\n or Handler.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext of WASI import object.\n \\param Fd the WASI mapped Fd.\n \\param [out] NativeHandler the raw Fd/Handler.\n\n \\returns the error code. Return `0` if the Native Handler is found.\n Return `1` if the `Cxt` is `NULL`.\n Return `2` if the given mapped Fd/handler is not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceWASIGetNativeHandler (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Fd : i32 , NativeHandler : * <span class="kw-2">mut </span>u64) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Initialize the WasmEdge_ModuleInstanceContext for the wasmedge_process\n specification.\n\n This function will initialize the wasmedge_process host module with the\n parameters.\n\n \\param AllowedCmds the allowed commands white list. NULL if the\n length is 0.\n \\param CmdsLen the length of the allowed commands white list.\n \\param AllowAll the boolean value to allow all commands. `false` is\n suggested. If this value is `true`, the allowed commands white list will not\n be recorded and all commands can be executed by wasmedge_process.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceInitWasmEdgeProcess (AllowedCmds : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , CmdsLen : u32 , AllowAll : bool) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the export module name of a module instance.\n\n The returned string object is linked to the module name of the module\n instance, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceGetModuleName (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the host data set into the module instance when creating.\n\n The returned data is owned by the module instance, and will be passed into\n the finalizer when deleting this module instance.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns host data. NULL if the module instance context is NULL or no host\n data set into the module instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceGetHostData (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported function instance context of a module instance.\n\n The result function instance context links to the function instance in the\n module instance context and owned by the module instance context, and the\n caller should __NOT__ call the `WasmEdge_FunctionInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the function name WasmEdge_String.\n\n \\returns pointer to the function instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindFunction (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported table instance context of a module instance.\n\n The result table instance context links to the table instance in the module\n instance context and owned by the module instance context, and the caller\n should __NOT__ call the `WasmEdge_TableInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the table name WasmEdge_String.\n\n \\returns pointer to the table instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindTable (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported memory instance context of a module instance.\n\n The result memory instance context links to the memory instance in the\n module instance context and owned by the module instance context, and the\n caller should __NOT__ call the `WasmEdge_MemoryInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the memory name WasmEdge_String.\n\n \\returns pointer to the memory instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindMemory (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported global instance context of a module instance.\n\n The result global instance context links to the global instance in the\n module instance context and owned by the module instance context, and the\n caller should __NOT__ call the `WasmEdge_GlobalInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param Name the global name WasmEdge_String.\n\n \\returns pointer to the global instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceFindGlobal (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported function list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported function list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListFunctionLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported function names of a module instance.\n\n The returned function names filled into the `Names` array are linked to the\n exported names of functions of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n function list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the function names.\n \\param Len the buffer length.\n\n \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListFunction (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported table list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported table list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListTableLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported table names of a module instance.\n\n The returned table names filled into the `Names` array are linked to the\n exported names of tables of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n table list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the table names.\n \\param Len the buffer length.\n\n \\returns actual exported table list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListTable (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported memory list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported memory list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListMemoryLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported memory names of a module instance.\n\n The returned memory names filled into the `Names` array are linked to the\n exported names of memories of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n memory list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the memory names.\n \\param Len the buffer length.\n\n \\returns actual exported memory list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListMemory (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported global list of a module instance.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n\n \\returns length of the exported global list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListGlobalLength (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the exported global names of a module instance.\n\n The returned global names filled into the `Names` array are linked to the\n exported names of globals of the module instance context, and the caller\n should __NOT__ call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the exported\n global list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext.\n \\param [out] Names the output WasmEdge_String buffer of the global names.\n \\param Len the buffer length.\n\n \\returns actual exported global list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceListGlobal (Cxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a function instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the function instance into the module\n instance. The caller should __NOT__ access or destroy the function instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the function instance.\n \\param Name the export function name WasmEdge_String.\n \\param FuncCxt the WasmEdge_FunctionInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddFunction (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , FuncCxt : * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a table instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the table instance into the module\n instance. The caller should __NOT__ access or destroy the table instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the table instance.\n \\param Name the export table name WasmEdge_String.\n \\param TableCxt the WasmEdge_TableInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddTable (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , TableCxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a memory instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the memory instance into the module\n instance. The caller should __NOT__ access or destroy the memory instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the memory instance.\n \\param Name the export memory name WasmEdge_String.\n \\param MemoryCxt the WasmEdge_MemoryInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddMemory (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , MemoryCxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Add a global instance context into a WasmEdge_ModuleInstanceContext.\n\n Export and move the ownership of the global instance into the module\n instance. The caller should __NOT__ access or destroy the global instance\n context after calling this function.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to add the global instance.\n \\param Name the export global name WasmEdge_String.\n \\param GlobalCxt the WasmEdge_GlobalInstanceContext to add.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceAddGlobal (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext , Name : WasmEdge_String , GlobalCxt : * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_ModuleInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n If the module instance has been registered into one or more store contexts,\n it will be automatically unregistered.\n\n \\param Cxt the WasmEdge_ModuleInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ModuleInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext) ; } <span class="kw">pub type </span>WasmEdge_HostFunc_t = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , CallFrameCxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext , Params : * <span class="kw">const </span>WasmEdge_Value , Returns : * <span class="kw-2">mut </span>WasmEdge_Value) -&gt; WasmEdge_Result &gt; ; <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_FunctionInstanceContext for host functions.\n\n The caller owns the object and should call `WasmEdge_FunctionInstanceDelete`\n to destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`. The following is an example to create a\n host function context.\n ```c\n WasmEdge_Result FuncAdd(void *Data,\n                         const WasmEdge_CallingFrameContext *CallFrameCxt,\n                         const WasmEdge_Value *In, WasmEdge_Value *Out) {\n   // Function to return A + B.\n   int32_t A = WasmEdge_ValueGetI32(In[0]);\n   int32_t B = WasmEdge_ValueGetI32(In[1]);\n   Out[0] = WasmEdge_ValueGenI32(A + B);\n   // Return execution status\n   return WasmEdge_Result_Success;\n }\n\n enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,\n                                    WasmEdge_ValType_I32};\n enum WasmEdge_ValType Returns[1] = {WasmEdge_ValType_I32};\n WasmEdge_FunctionTypeContext *FuncType =\n     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);\n WasmEdge_FunctionInstanceContext *HostFunc =\n     WasmEdge_FunctionInstanceCreate(FuncType, FuncAdd, NULL, 0);\n WasmEdge_FunctionTypeDelete(FuncType);\n ...\n ```\n\n \\param Type the function type context to describe the host function\n signature.\n \\param HostFunc the host function pointer. The host function signature must\n be as following:\n ```c\n typedef WasmEdge_Result (*WasmEdge_HostFunc_t)(\n     void *Data,\n     const WasmEdge_CallingFrameContext *CallFrameCxt,\n     const WasmEdge_Value *Params,\n     WasmEdge_Value *Returns);\n ```\n The `Params` is the input parameters array with length guaranteed to be the\n same as the parameter types in the `Type`. The `Returns` is the output\n results array with length guaranteed to be the same as the result types in\n the `Type`. The return value is `WasmEdge_Result` for the execution status.\n \\param Data the additional object, such as the pointer to a data structure,\n to set to this host function context. The caller should guarantee the life\n cycle of the object. NULL if the additional data object is not needed.\n \\param Cost the function cost in statistics. Pass 0 if the calculation is\n not needed.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceCreate (Type : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , HostFunc : WasmEdge_HostFunc_t , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Cost : u64) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">pub type </span>WasmEdge_WrapFunc_t = :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(This : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , CallFrameCxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result &gt; ; <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_FunctionInstanceContext for host functions.\n\n This function is for the languages which cannot pass the function pointer of\n the host function into this shared library directly. The caller owns the\n object and should call `WasmEdge_FunctionInstanceDelete` to destroy it if\n the returned object is not added into a `WasmEdge_ModuleInstanceContext`.\n The following is an example to create a host function context for other\n languages.\n ```c\n // `RealFunc` is the pointer to the function in other languages.\n\n WasmEdge_Result FuncAddWrap(\n     void *This, void *Data,\n     const WasmEdge_CallingFrameContext *CallFrameCxt,\n     const WasmEdge_Value *In, const uint32_t InLen, WasmEdge_Value *Out,\n     const uint32_t OutLen) {\n   // Wrapper function of host function to return A + B.\n\n   // `This` is the same as `RealFunc`.\n   int32_t A = WasmEdge_ValueGetI32(In[0]);\n   int32_t B = WasmEdge_ValueGetI32(In[1]);\n\n   // Call the function of `This` in the host language ...\n   int32_t Result = ...;\n\n   Out[0] = Result;\n   // Return the execution status.\n   return WasmEdge_Result_Success;\n }\n\n enum WasmEdge_ValType Params[2] = {WasmEdge_ValType_I32,\n                                    WasmEdge_ValType_I32};\n enum WasmEdge_ValType Returns[1] = {WasmEdge_ValType_I32};\n WasmEdge_FunctionTypeContext *FuncType =\n     WasmEdge_FunctionTypeCreate(Params, 2, Returns, 1);\n WasmEdge_FunctionInstanceContext *HostFunc =\n     WasmEdge_FunctionInstanceCreateBinding(\n         FuncType, FuncAddWrap, RealFunc, NULL, 0);\n WasmEdge_FunctionTypeDelete(FuncType);\n ...\n ```\n\n \\param Type the function type context to describe the host function\n signature.\n \\param WrapFunc the wrapper function pointer. The wrapper function signature\n must be as following:\n ```c\n typedef WasmEdge_Result (*WasmEdge_WrapFunc_t)(\n     void *This,\n     void *Data,\n     WasmEdge_CallingFrameContext *FrameCxt,\n     const WasmEdge_Value *Params,\n     const uint32_t ParamLen,\n     WasmEdge_Value *Returns,\n     const uint32_t ReturnLen);\n ```\n The `This` is the pointer the same as the `Binding` parameter of this\n function. The `Params` is the input parameters array with length guaranteed\n to be the same as the parameter types in the `Type`, and the `ParamLen` is\n the length of the array. The `Returns` is the output results array with\n length guaranteed to be the same as the result types in the `Type`, and the\n `ReturnLen` is the length of the array. The return value is\n `WasmEdge_Result` for the execution status.\n \\param Binding the `this` pointer of the host function target or the\n function indexing maintained by the caller which can specify the host\n function. When invoking the host function, this pointer will be the first\n argument of the wrapper function.\n \\param Data the additional object, such as the pointer to a data structure,\n to set to this host function context. The caller should guarantee the life\n cycle of the object. NULL if the additional data object is not needed.\n \\param Cost the function cost in statistics. Pass 0 if the calculation is\n not needed.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceCreateBinding (Type : * <span class="kw">const </span>WasmEdge_FunctionTypeContext , WrapFunc : WasmEdge_WrapFunc_t , Binding : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Cost : u64) -&gt; * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function data field of the function instance.\n\n The function data is passed when creating the FunctionInstance.\n\n \\param Cxt the WasmEdge_FunctionInstanceContext.\n\n \\returns pointer to Data, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceGetData (Cxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_void ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function type context of the function instance.\n\n The function type context links to the function type in the function\n instance context and owned by the context. The caller should __NOT__ call\n the `WasmEdge_FunctionTypeDelete`.\n\n \\param Cxt the WasmEdge_FunctionInstanceContext.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceGetFunctionType (Cxt : * <span class="kw">const </span>WasmEdge_FunctionInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_FunctionInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_FunctionInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_FunctionInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_FunctionInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_TableInstanceContext.\n\n The caller owns the object and should call `WasmEdge_TableInstanceDelete` to\n destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`.\n\n \\param TabType the table type context to initialize the table instance\n context.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceCreate (TabType : * <span class="kw">const </span>WasmEdge_TableTypeContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the table type context from a table instance.\n\n The table type context links to the table type in the table instance context\n and owned by the context. The caller should __NOT__ call the\n `WasmEdge_TableTypeDelete`.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGetTableType (Cxt : * <span class="kw">const </span>WasmEdge_TableInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_TableTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the reference value in a table instance.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n \\param [out] Data the result reference value.\n \\param Offset the reference value offset (index) in the table instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGetData (Cxt : * <span class="kw">const </span>WasmEdge_TableInstanceContext , Data : * <span class="kw-2">mut </span>WasmEdge_Value , Offset : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the reference value into a table instance.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n \\param Data the reference value to set into the table instance.\n \\param Offset the reference value offset (index) in the table instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceSetData (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext , Data : WasmEdge_Value , Offset : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the size of a table instance.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n\n \\returns the size of the table instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGetSize (Cxt : * <span class="kw">const </span>WasmEdge_TableInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Grow a table instance with a size.\n\n \\param Cxt the WasmEdge_TableInstanceContext.\n \\param Size the count of reference values to grow in the table instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceGrow (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext , Size : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_TableInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_TableInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_TableInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_TableInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_MemoryInstanceContext.\n\n The caller owns the object and should call `WasmEdge_MemoryInstanceDelete`\n to destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`.\n\n \\param MemType the memory type context to initialize the memory instance\n context.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceCreate (MemType : * <span class="kw">const </span>WasmEdge_MemoryTypeContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the memory type context from a memory instance.\n\n The memory type context links to the memory type in the memory instance\n context and owned by the context. The caller should __NOT__ call the\n `WasmEdge_MemoryTypeDelete`.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetMemoryType (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_MemoryTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Copy the data to the output buffer from a memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param [out] Data the result data buffer of copying destination.\n \\param Offset the data start offset in the memory instance.\n \\param Length the requested data length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will failed.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetData (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext , Data : * <span class="kw-2">mut </span>u8 , Offset : u32 , Length : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Copy the data into a memory instance from the input buffer.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Data the data buffer to copy.\n \\param Offset the data start offset in the memory instance.\n \\param Length the data buffer length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will failed.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceSetData (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext , Data : * <span class="kw">const </span>u8 , Offset : u32 , Length : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the data pointer in a memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Offset the data start offset in the memory instance.\n \\param Length the requested data length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will return NULL.\n\n \\returns the pointer to data with the start offset. NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetPointer (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext , Offset : u32 , Length : u32) -&gt; * <span class="kw-2">mut </span>u8 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the const data pointer in a const memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Offset the data start offset in the memory instance.\n \\param Length the requested data length. If the `Offset + Length` is larger\n than the data size in the memory instance, this function will return NULL.\n\n \\returns the pointer to data with the start offset. NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetPointerConst (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext , Offset : u32 , Length : u32) -&gt; * <span class="kw">const </span>u8 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the current page size (64 KiB of each page) of a memory instance.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n\n \\returns the page size of the memory instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGetPageSize (Cxt : * <span class="kw">const </span>WasmEdge_MemoryInstanceContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Grow a memory instance with a page size.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext.\n \\param Page the page count to grow in the memory instance.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceGrowPage (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext , Page : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_MemoryInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_MemoryInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_MemoryInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_GlobalInstanceContext.\n\n The caller owns the object and should call `WasmEdge_GlobalInstanceDelete`\n to destroy it if the returned object is not added into a\n `WasmEdge_ModuleInstanceContext`.\n\n \\param GlobType the global type context to initialize the global instance\n context.\n \\param Value the initial value with its value type of the global instance.\n This function will fail if the value type of `GlobType` and `Value` are not\n the same.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceCreate (GlobType : * <span class="kw">const </span>WasmEdge_GlobalTypeContext , Value : WasmEdge_Value) -&gt; * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the global type context from a global instance.\n\n The global type context links to the global type in the global instance\n context and owned by the context. The caller should __NOT__ call the\n `WasmEdge_GlobalTypeDelete`.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceGetGlobalType (Cxt : * <span class="kw">const </span>WasmEdge_GlobalInstanceContext) -&gt; * <span class="kw">const </span>WasmEdge_GlobalTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the value from a global instance.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext.\n\n \\returns the current value of the global instance.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceGetValue (Cxt : * <span class="kw">const </span>WasmEdge_GlobalInstanceContext) -&gt; WasmEdge_Value ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Set the value from a global instance.\n\n This function will do nothing if the global context is set as the `Const`\n mutation or the value type not matched.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext.\n \\param Value the value to set into the global context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceSetValue (Cxt : * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext , Value : WasmEdge_Value) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_GlobalInstanceContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_GlobalInstanceContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_GlobalInstanceDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_GlobalInstanceContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the executor context from the current calling frame.\n\n \\param Cxt the WasmEdge_CallingFrameContext.\n\n \\returns the executor context, NULL if the Cxt is NULL.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CallingFrameGetExecutor (Cxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ExecutorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module instance of the current calling frame.\n\n When a WASM function is executing and start to call a host function, a frame\n with the module instance which the WASM function belongs to will be pushed\n onto the stack. And therefore the calling frame context will record that\n module instance.\n So in one case that the module instance will be `NULL`: developers execute\n the function instance which is a host function and not added into a module\n instance.\n\n \\param Cxt the WasmEdge_CallingFrameContext.\n\n \\returns the module instance of the current calling frame.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CallingFrameGetModuleInstance (Cxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the memory instance by index from the module instance of the current\n calling frame.\n\n By default, a WASM module only have one memory instance after instantiation.\n Therefore, developers can use:\n   `WasmEdge_CallingFrameGetMemoryInstance(Cxt, 0)`\n to get the memory instance in host function body.\n This extension is for the WASM multiple memories proposal. After enabling\n the proposal, there may be greater than 1 memory instances in a WASM module.\n So developers can use this function to access the memory instances which are\n not in 0 index.\n\n \\param Cxt the WasmEdge_CallingFrameContext.\n \\param Idx the index of memory instance in the module instance.\n\n \\returns the memory instance, NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_CallingFrameGetMemoryInstance (Cxt : * <span class="kw">const </span>WasmEdge_CallingFrameContext , Idx : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_MemoryInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait a WasmEdge_Async execution.\n\n \\param Cxt the WasmEdge_ASync.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncWait (Cxt : * <span class="kw">const </span>WasmEdge_Async) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait a WasmEdge_Async execution with timeout.\n\n \\param Cxt the WasmEdge_ASync.\n \\param Milliseconds times to wait.\n\n \\returns Result of waiting, true for execution ended, false for timeout\n occurred.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncWaitFor (Cxt : * <span class="kw">const </span>WasmEdge_Async , Milliseconds : u64) -&gt; bool ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Cancel a WasmEdge_Async execution.\n\n \\param Cxt the WasmEdge_ASync.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncCancel (Cxt : * <span class="kw-2">mut </span>WasmEdge_Async) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait and get the return list length of the WasmEdge_Async execution.\n\n This function will wait until the execution finished and return the return\n value list length of the executed function. This function will return 0 if\n the `Cxt` is NULL, the execution was failed, or the execution was canceled.\n Developers can call the `WasmEdge_AsyncGet` to get the execution status and\n the return values.\n\n \\param Cxt the WasmEdge_ASync.\n\n \\returns the return list length of the executed function.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncGetReturnsLength (Cxt : * <span class="kw">const </span>WasmEdge_Async) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Wait and get the result of WasmEdge_Async execution.\n\n This function will wait until the execution finished and return the\n execution status and the return values.\n If the `Returns` buffer length is smaller than the arity of the function,\n the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_ASync.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncGet (Cxt : * <span class="kw">const </span>WasmEdge_Async , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_Async.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_ASync to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_AsyncDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_Async) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Creation of the WasmEdge_VMContext.\n\n The caller owns the object and should call `WasmEdge_VMDelete` to destroy\n it.\n\n \\param ConfCxt the WasmEdge_ConfigureContext as the configuration of VM.\n NULL for the default configuration.\n \\param StoreCxt the WasmEdge_StoreContext as the external WASM store of VM.\n The instantiation and execution will refer to this store context, and the\n life cycle should be ensured until the VM context is deleted. NULL for the\n default store owned by `WasmEdge_VMContext`.\n\n \\returns pointer to context, NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMCreate (ConfCxt : * <span class="kw">const </span>WasmEdge_ConfigureContext , StoreCxt : * <span class="kw-2">mut </span>WasmEdge_StoreContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_VMContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register and instantiate WASM into the store in VM from a WASM file.\n\n Load a WASM file from the path, and register all exported instances and\n instantiate them into the store into the VM with their exported name and\n module name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ModuleName the WasmEdge_String of module name for all exported\n instances.\n \\param Path the NULL-terminated C string of the WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register and instantiate WASM into the store in VM from a buffer.\n\n Load a WASM module from a buffer, and register all exported instances and\n instantiate them into the store into the VM with their exported name and\n module name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ModuleName the WasmEdge_String of module name for all exported\n instances.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , Buf : * <span class="kw">const </span>u8 , BufLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate and register an AST Module into a named module instance in VM.\n\n Load from the AST Module, and register all exported instances and\n instantiate them into the store in VM with their exported name and module\n name.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ModuleName the WasmEdge_String of module name for all exported\n instances.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register a module instance into the store in VM with exporting its module\n name.\n\n After calling this function, the existing module instance will be registered\n into the store context in this VM, and the other modules can import the\n exported instances for linking when instantiation. Developers SHOULD\n guarantee the life cycle of this existing module instance, or the error will\n occur when in execution after the module instance being destroyed if it has\n been imported by other modules. That is, developers should call the\n `WasmEdge_ModuleInstanceDelete` if this existing module instance will not be\n used anymore or after the deletion of this VM. When the module instance is\n deleted, it will be unregistered to the store context in this VM\n automatically.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext which contains the store.\n \\param ImportCxt the WasmEdge_ModuleInstanceContext to register.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRegisterModuleFromImport (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ImportCxt : * <span class="kw">const </span>WasmEdge_ModuleInstanceContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WASM file and invoke a function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the file path, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Path the NULL-terminated C string of the WASM file path.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRunWasmFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a buffer and invoke a function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from a buffer, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRunWasmFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32 , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WasmEdge AST Module and invoke a function\n by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the WasmEdge AST Module, and then\n invoke the function by name and parameters. If the `Returns` buffer length\n is smaller than the arity of the function, the overflowed return values will\n be discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMRunWasmFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WASM file and asynchronous invoke a\n function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the file path, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy\n it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Path the NULL-terminated C string of the WASM file path.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncRunWasmFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a buffer and asynchronous invoke a function\n by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from a buffer, and then invoke a\n function by name and parameters. If the `Returns` buffer length is smaller\n than the arity of the function, the overflowed return values will be\n discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy\n it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncRunWasmFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32 , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the WASM module from a WasmEdge AST Module and asynchronous\n invoke a function by name.\n\n This is the function to invoke a WASM function rapidly.\n Load and instantiate the WASM module from the WasmEdge AST Module, and then\n invoke the function by name and parameters. If the `Returns` buffer length\n is smaller than the arity of the function, the overflowed return values will\n be discarded.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n The caller owns the object and should call `WasmEdge_AsyncDelete` to destroy\n it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncRunWasmFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the WASM module from a WASM file.\n\n This is the first step to invoke a WASM function step by step.\n Load and parse the WASM module from the file path. You can then call\n `WasmEdge_VMValidate` for the next step.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Path the NULL-terminated C string of the WASM file path.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMLoadWasmFromFile (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the WASM module from a buffer.\n\n This is the first step to invoke a WASM function step by step.\n Load and parse the WASM module from a buffer. You can then call\n `WasmEdge_VMValidate` for the next step.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Buf the buffer of WASM binary.\n \\param BufLen the length of the buffer.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMLoadWasmFromBuffer (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , Buf : * <span class="kw">const </span>u8 , BufLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the WASM module from loaded WasmEdge AST Module.\n\n This is the first step to invoke a WASM function step by step.\n Copy the loaded WasmEdge AST Module context into VM. The VM context has no\n dependency on the input AST Module context. You can then call\n `WasmEdge_VMValidate` for the next step.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ASTCxt the WasmEdge AST Module context generated by loader or\n compiler.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMLoadWasmFromASTModule (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ASTCxt : * <span class="kw">const </span>WasmEdge_ASTModuleContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Validate the WASM module loaded into the VM context.\n\n This is the second step to invoke a WASM function step by step.\n After loading a WASM module into VM context, You can call this function to\n validate it. And you can then call `WasmEdge_VMInstantiate` for the next\n step. Note that only validated WASM modules can be instantiated in the VM\n context.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMValidate (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Instantiate the validated WASM module in the VM context.\n\n This is the third step to invoke a WASM function step by step.\n After validating a WASM module in the VM context, You can call this function\n to instantiate it. And you can then call `WasmEdge_VMExecute` for invoking\n the exported function in this WASM module.\n After calling this function, a new module instance is instantiated, and the\n old one will be destroyed.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMInstantiate (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Invoke a WASM function by name.\n\n This is the final step to invoke a WASM function step by step.\n After instantiating a WASM module in the VM context, the WASM module is\n registered into the store in the VM context as an anonymous module. Then you\n can repeatedly call this function to invoke the exported WASM functions by\n their names until the VM context is reset or a new WASM module is registered\n or loaded. For calling the functions in registered WASM modules with module\n names, please use `WasmEdge_VMExecuteRegistered` instead. If the `Returns`\n buffer length is smaller than the arity of the function, the overflowed\n return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMExecute (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Invoke a WASM function by its module name and function name.\n\n After registering a WASM module in the VM context, you can repeatedly call\n this function to invoke exported WASM functions by their module names and\n function names until the VM context is reset. If the `Returns` buffer length\n is smaller than the arity of the function, the overflowed return values will\n be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n \\param [out] Returns the WasmEdge_Value buffer to fill the return values.\n \\param ReturnLen the return buffer length.\n\n \\returns WasmEdge_Result. Call `WasmEdge_ResultGetMessage` for the error\n message.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMExecuteRegistered (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32 , Returns : * <span class="kw-2">mut </span>WasmEdge_Value , ReturnLen : u32) -&gt; WasmEdge_Result ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Asynchronous invoke a WASM function by name.\n\n This is the final step to invoke a WASM function step by step.\n After instantiating a WASM module in the VM context, the WASM module is\n registered into the store in the VM context as an anonymous module. Then you\n can repeatedly call this function to invoke the exported WASM functions by\n their names until the VM context is reset or a new WASM module is registered\n or loaded. For calling the functions in registered WASM modules with module\n names, please use `WasmEdge_VMAsyncExecuteRegistered` instead.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncExecute (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Asynchronous invoke a WASM function by its module name and function name.\n\n After registering a WASM module in the VM context, you can repeatedly call\n this function to invoke exported WASM functions by their module names and\n function names until the VM context is reset.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n \\param FuncName the function name WasmEdge_String.\n \\param Params the WasmEdge_Value buffer with the parameter values.\n \\param ParamLen the parameter buffer length.\n\n \\returns WasmEdge_Async. Call `WasmEdge_AsyncGet` for the result, and call\n `WasmEdge_AsyncDelete` to destroy this object.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMAsyncExecuteRegistered (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , FuncName : WasmEdge_String , Params : * <span class="kw">const </span>WasmEdge_Value , ParamLen : u32) -&gt; * <span class="kw-2">mut </span>WasmEdge_Async ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function type by function name.\n\n After instantiating a WASM module in the VM context, the WASM module is\n registered into the store in the VM context as an anonymous module. Then you\n can call this function to get the function type by the exported function\n name until the VM context is reset or a new WASM module is registered or\n loaded. For getting the function type of functions in registered WASM\n modules with module names, please use `WasmEdge_VMGetFunctionTypeRegistered`\n instead.\n The returned function type context are linked to the context owned by the VM\n context, and the caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete` to destroy it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param FuncName the function name WasmEdge_String.\n\n \\returns the function type. NULL if the function not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionType (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , FuncName : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the function type by function name.\n\n After registering a WASM module in the VM context, you can call this\n function to get the function type by the functions&#39; exported module names\n and function names until the VM context is reset.\n The returned function type context are linked to the context owned by the VM\n context, and the caller should __NOT__ call the\n `WasmEdge_FunctionTypeDelete` to destroy it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n \\param FuncName the function name WasmEdge_String.\n\n \\returns the function type. NULL if the function not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionTypeRegistered (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , ModuleName : WasmEdge_String , FuncName : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_FunctionTypeContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Reset of WasmEdge_VMContext.\n\n After calling this function, the statistics, loaded module, the instantiated\n instances, and the registered instances except the WASI and plug-ins will\n all be cleared.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext to reset.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMCleanup (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of exported function list.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns length of exported function list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionListLength (Cxt : * <span class="kw">const </span>WasmEdge_VMContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the exported function list.\n\n The returned function names filled into the `Names` array link to the\n exported names of functions owned by the vm context, and the caller should\n __NOT__ call the `WasmEdge_StringDelete` to destroy them.\n The function type contexts filled into the `FuncTypes` array of the\n corresponding function names link to the context owned by the VM context.\n The caller should __NOT__ call the `WasmEdge_FunctionTypeDelete` to destroy\n them.\n If the `Names` and `FuncTypes` buffer lengths are smaller than the result of\n the exported function list size, the overflowed return values will be\n discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param [out] Names the output names WasmEdge_String buffer of exported\n functions. Can be NULL if names are not needed.\n \\param [out] FuncTypes the function type contexts buffer. Can be NULL if\n function types are not needed.\n \\param Len the buffer length.\n\n \\returns actual exported function list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetFunctionList (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , FuncTypes : * <span class="kw-2">mut </span>* <span class="kw">const </span>WasmEdge_FunctionTypeContext , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the module instance corresponding to the WasmEdge_HostRegistration\n settings.\n\n When creating the VM context with a configuration, the built-in host module\n will be registered according to the `WasmEdge_HostRegistration` settings\n added into the `WasmEdge_ConfigureContext`. You can call this function to\n get the `WasmEdge_ModuleInstanceContext` corresponding to the settings. The\n module instance context links to the context owned by the VM context. The\n caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete`.\n\n ```c\n WasmEdge_ConfigureContext *Conf = WasmEdge_ConfigureCreate();\n WasmEdge_ConfigureAddHostRegistration(Conf, WasmEdge_HostRegistration_Wasi);\n WasmEdge_VMContext *VM = WasmEdge_VMCreate(Conf, NULL);\n WasmEdge_ModuleInstanceContext *WasiMod =\n     WasmEdge_VMGetImportModuleContext(VM, WasmEdge_HostRegistration_Wasi);\n ```\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Reg the host registration value to get the import module.\n\n \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetImportModuleContext (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , Reg : WasmEdge_HostRegistration) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the current instantiated module in VM.\n\n After instantiating a module instance into the VM, developers can call this\n API to get the module instance to retrieve the exported instances. The\n module instance context links to the context owned by the VM context. The\n caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetActiveModule (Cxt : * <span class="kw">const </span>WasmEdge_VMContext) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the registered module in VM by the module name.\n\n After registering a WASM module into the VM context, developers can call\n this function to get the module instance by the module name. The returned\n module instance context links to the context owned by the VM context, and\n the caller should __NOT__ call the `WasmEdge_ModuleInstanceDelete` to\n destroy it.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param ModuleName the module name WasmEdge_String.\n\n \\returns pointer to the module instance context. NULL if not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetRegisteredModule (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , ModuleName : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of registered module list in the WasmEdge_VMContext.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns length of registered module list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMListRegisteredModuleLength (Cxt : * <span class="kw">const </span>WasmEdge_VMContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the registered module names in the WasmEdge_VMContext.\n\n This function will list all registered module names.\n The returned module names filled into the `Names` array are linked to the\n registered module names in the VM context, and the caller should __NOT__\n call the `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the registered\n named module list size, the overflowed return values will be discarded.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param [out] Names the output names WasmEdge_String buffer of the registered\n modules.\n \\param Len the buffer length.\n\n \\returns actual registered module list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMListRegisteredModule (Cxt : * <span class="kw">const </span>WasmEdge_VMContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the store context used in the WasmEdge_VMContext.\n\n The returned store context links to the store in the VM context and owned by\n the VM context. This function will return NULL if error occurs. The caller\n should __NOT__ call the `WasmEdge_StoreDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the store context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetStoreContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_StoreContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the loader context used in the WasmEdge_VMContext.\n\n The returned loader context links to the loader in the VM context and owned\n by the VM context. This function will return NULL if error occurs. The\n caller should __NOT__ call the `WasmEdge_LoaderDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the loader context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetLoaderContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_LoaderContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the validator context used in the WasmEdge_VMContext.\n\n The returned validator context links to the validator in the VM context and\n owned by the VM context. This function will return NULL if error occurs. The\n caller should __NOT__ call the `WasmEdge_ValidatorDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the validator context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetValidatorContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ValidatorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the executor context used in the WasmEdge_VMContext.\n\n The returned executor context links to the executor in the VM context and\n owned by the VM context. This function will return NULL if error occurs. The\n caller should __NOT__ call the `WasmEdge_ExecutorDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the executor context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetExecutorContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_ExecutorContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the statistics context used in the WasmEdge_VMContext.\n\n The statistics context links to the statistics in the VM context and owned\n by the VM context. The caller should __NOT__ call the\n `WasmEdge_StatisticsDelete`.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n\n \\returns pointer to the statistics context.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMGetStatisticsContext (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) -&gt; * <span class="kw-2">mut </span>WasmEdge_StatisticsContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Deletion of the WasmEdge_VMContext.\n\n After calling this function, the context will be destroyed and should\n __NOT__ be used.\n\n \\param Cxt the WasmEdge_VMContext to destroy.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_VMDelete (Cxt : * <span class="kw-2">mut </span>WasmEdge_VMContext) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Entrypoint for the compiler tool.\n\n This function provides an entrypoint to the WasmEdge AOT compiler tool with\n the command line arguments.\n\n \\param Argc the argument count.\n \\param Argv the argument vector.\n\n \\returns the execution status.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Driver_Compiler (Argc : :: std :: os :: raw :: c_int , Argv : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Entrypoint for the runtime tool.\n\n This function provides an entrypoint to the WasmEdge runtime tool with the\n command line arguments.\n\n \\param Argc the argument count.\n \\param Argv the argument vector.\n\n \\returns the execution status.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Driver_Tool (Argc : :: std :: os :: raw :: c_int , Argv : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Entrypoint for the unified tool.\n\n This function provides an entrypoint to the WasmEdge unified tool with the\n command line arguments.\n\n \\param Argc the argument count.\n \\param Argv the argument vector.\n\n \\returns the execution status.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Driver_UniTool (Argc : :: std :: os :: raw :: c_int , Argv : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load plugins with the default search paths.\n\n The default paths are:\n   1. The environment variable \&quot;WASMEDGE_PLUGIN_PATH\&quot;.\n   2. The \&quot;../plugin/\&quot; directory related to the WasmEdge installation path.\n   3. The \&quot;wasmedge/\&quot; directory under the library path if the WasmEdge is\n      installed under the \&quot;/usr\&quot;.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginLoadWithDefaultPaths () ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Load the plugin with the given file or directory.\n\n For the given file path, this function will load the plug-in.\n For the given directory path, this function will load the plug-ins under the\n directory recursively.\n\n \\param Path the path to plug-in file or directory.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginLoadFromPath (Path : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of loaded plug-in list.\n\n \\returns length of loaded plug-in list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListPluginsLength () -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the loaded plug-ins with their names.\n\n The returned plug-in names filled into the `Names` array are owned by the\n internal WasmEdge plug-in storage, and the caller should __NOT__ call the\n `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the loaded\n plug-in list size, the overflowed return values will be discarded.\n\n \\param [out] Names the output WasmEdge_String buffer of the function names.\n \\param Len the buffer length.\n\n \\returns actual loaded plug-in list size.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListPlugins (Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Find the loaded plug-in context by name.\n\n After loading the plug-ins from default paths or the given path, developers\n can use this API to retrieve the plug-in context by name. Then developers\n can create the module instance from the plug-in contexts.\n\n \\param Name the plug-in name WasmEdge_String.\n\n \\returns pointer to the plug-in context. NULL if the plug-in not found.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginFind (Name : WasmEdge_String) -&gt; * <span class="kw">const </span>WasmEdge_PluginContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the plug-in name of the plug-in context.\n\n The returned string object is linked to the plug-in name of the plug-in\n context, and the caller should __NOT__ call the `WasmEdge_StringDelete`.\n\n \\param Cxt the WasmEdge_PluginContext.\n\n \\returns string object. Length will be 0 and Buf will be NULL if failed.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginGetPluginName (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext) -&gt; WasmEdge_String ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Get the length of module list in the plug-in context.\n\n There may be several modules in a plug-in. Developers can use this function\n to get the length of the module list in a plug-in.\n\n \\param Cxt the WasmEdge_PluginContext to get the length of the module list.\n\n \\returns length of module list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListModuleLength (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; List the modules in the plug-in context with their names.\n\n The returned module names filled into the `Names` array are owned by the\n internal WasmEdge plug-in storage, and the caller should __NOT__ call the\n `WasmEdge_StringDelete`.\n If the `Names` buffer length is smaller than the result of the loaded\n plug-in list size, the overflowed return values will be discarded.\n\n \\param Cxt the WasmEdge_PluginContext to list the modules.\n \\param [out] Names the output WasmEdge_String buffer of the function names.\n \\param Len the buffer length.\n\n \\returns actual module list size of the plug-in.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginListModule (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext , Names : * <span class="kw-2">mut </span>WasmEdge_String , Len : u32) -&gt; u32 ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Create the module instance in the plug-in by the module name.\n\n By giving the module name, developers can retrieve the module in the plug-in\n and create the module instance.\n The caller owns the object and should call `WasmEdge_ModuleInstanceDelete`\n to destroy it.\n\n \\param Cxt the WasmEdge_PluginContext to retrieve and create module.\n \\param ModuleName the module name to retrieve.\n\n \\returns pointer to the module instance context, NULL if the module name not\n found in the plug-in or the plug-in is not valid.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginCreateModule (Cxt : * <span class="kw">const </span>WasmEdge_PluginContext , ModuleName : WasmEdge_String) -&gt; * <span class="kw-2">mut </span>WasmEdge_ModuleInstanceContext ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Initialize the wasi_nn plug-in.\n\n This function will initialize the wasi_nn plug-in with the preloads string\n list. Only available after loading the wasi_nn plug-in and before creating\n the module instance from the plug-in.\n\n \\param NNPreloads the preload string list. NULL if the length is 0.\n \\param PreloadsLen the length of the preload list.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_PluginInitWASINN (NNPreloads : * <span class="kw">const </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , PreloadsLen : u32) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Implement by plugins for returning the plugin descriptor.\n\n \\returns the plugin descriptor.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_Plugin_GetDescriptor () -&gt; * <span class="kw">const </span>WasmEdge_PluginDescriptor ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register a host function that will be invoked before executing any host\n functions.\n\n There is only one pre-host-function. After calling this function, the\n previous registered host function will be replaced. This is a experimental\n feature. Use it at your own risk.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_ExecutorContext.\n \\param Data the host data to set into the given host function. When calling\n the Func, this pointer will be the argument of the Func function.\n \\param Func the function to be invoked before executing any other host\n functions.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorExperimentalRegisterPreHostFunction (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Func : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) &gt;) ; } <span class="kw">extern </span><span class="string">&quot;C&quot; </span>{ # [doc = <span class="string">&quot; Register a host function that will be invoked after executing any host\n functions.\n\n There is only one post-host-function. After calling this function, the\n previous registered host function will be replaced. This is a experimental\n feature. Use it at your own risk.\n\n This function is thread-safe.\n\n \\param Cxt the WasmEdge_VMContext.\n \\param Data the host data to set into the given host function. When calling\n the Func, this pointer will be the argument of the Func function.\n \\param Func the function to be invoked after executing any other host\n functions.&quot;</span>] <span class="kw">pub fn </span>WasmEdge_ExecutorExperimentalRegisterPostHostFunction (Cxt : * <span class="kw-2">mut </span>WasmEdge_ExecutorContext , Data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , Func : :: std :: option :: <span class="prelude-ty">Option </span>&lt; <span class="kw">unsafe extern </span><span class="string">&quot;C&quot; </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) &gt;) ; }</code></pre></div></section></main></body></html>